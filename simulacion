import simpy
import random
import numpy as np
from typing import Dict, Any, List, Tuple
import itertools

# ---------------------- CONFIGURACIÓN GLOBAL ----------------------

# Semilla para reproducibilidad
random.seed(9)

# Parámetros de simulación
SIM_TIME = 24 * 60  # 24 horas en minutos

# Intervalos de llegada de pacientes (en minutos)
PATIENT_INTERVALS = {
    "weekday": 15,  # Un paciente cada 15 minutos en días normales
    "weekend": 10,  # Un paciente cada 10 minutos en fines de semana
    "holiday": 8    # Un paciente cada 8 minutos en días festivos
}

# Tiempos de atención (en minutos)
TRIAGE_TIME = 10  # Tiempo de evaluación por enfermera
DOCTOR_TIME = {1: 30, 2: 25, 3: 20, 4: 15, 5: 10}  # Tiempo según severidad
LAB_TIME = 20  # Tiempo de análisis en laboratorio
XRAY_TIME = 15  # Tiempo de rayos X

# Costos de recursos (en quetzales)
DOCTOR_SALARY_PER_HOUR = 200  # Q200 por hora
NURSE_SALARY_PER_HOUR = 100   # Q100 por hora
LAB_EQUIPMENT_COST = 500000   # Q500,000 por equipo (costo inicial)
XRAY_EQUIPMENT_COST = 800000  # Q800,000 por equipo (costo inicial)
EQUIPMENT_LIFESPAN_DAYS = 5 * 365  # 5 años en días

# Variables globales para estadísticas
all_patient_times = []
severity_distribution = {1: 0, 2: 0, 3: 0, 4: 0, 5: 0}
waiting_times_by_severity = {1: [], 2: [], 3: [], 4: [], 5: []}

# ---------------------- CLASES Y FUNCIONES ----------------------

class Hospital:
    """Modelo del hospital con todos sus recursos y procesos"""
    
    def __init__(self, env: simpy.Environment, num_doctors: int, num_nurses: int, 
                 num_labs: int, num_xray: int):
        """Inicializa el hospital con sus recursos"""
        self.env = env
        # Recursos con prioridad
        self.doctors = simpy.PriorityResource(env, capacity=num_doctors)
        self.nurses = simpy.PriorityResource(env, capacity=num_nurses)
        self.labs = simpy.PriorityResource(env, capacity=num_labs)
        self.xray = simpy.PriorityResource(env, capacity=num_xray)
        
        # Contadores
        self.patients_seen = 0
        self.patients_waiting = 0
        
        # Para seguimiento de utilización
        self.doctor_utilization = []
        self.nurse_utilization = []
        self.lab_utilization = []
        self.xray_utilization = []
        
    def patient_generator(self, interval_type: str = "weekday"):
        """Genera pacientes que llegan a la sala de emergencias"""
        i = 0
        interval = PATIENT_INTERVALS.get(interval_type, PATIENT_INTERVALS["weekday"])
            
        while True:
            # Esperar hasta el próximo paciente
            yield self.env.timeout(random.expovariate(1.0 / interval))
            
            # Crear un nuevo paciente
            i += 1
            severity = random.randint(1, 5)  # Asignar severidad aleatoria (1 es lo más grave)
            severity_distribution[severity] += 1
            
            # Registrar llegada para estadísticas
            arrival_time = self.env.now
            
            # Comentado para reducir salida
            # print(f"Paciente {i} llega en tiempo {arrival_time:.2f} con severidad {severity}")
            self.patients_waiting += 1
            
            # Iniciar el proceso del paciente
            self.env.process(self.patient_process(i, severity, arrival_time))
    
    def patient_process(self, patient_id: int, severity: int, arrival_time: float):
        """Proceso completo de atención de un paciente"""
        # Paso 1: Triage (evaluación inicial por enfermera)
        # print(f"Paciente {patient_id} espera triage en tiempo {self.env.now:.2f}")
        triage_start = self.env.now
        
        with self.nurses.request(priority=severity) as req:
            yield req
            nurse_start = self.env.now
            # print(f"Paciente {patient_id} inicia triage en tiempo {self.env.now:.2f}")
            yield self.env.timeout(TRIAGE_TIME)
            # print(f"Paciente {patient_id} termina triage en tiempo {self.env.now:.2f}")
            self.nurse_utilization.append((nurse_start, self.env.now))
        
        triage_time = self.env.now - triage_start
        
        # Decisión de laboratorio y rayos X (más probable para casos más graves)
        needs_lab = random.random() < (1 - (severity - 1) * 0.15)  # 100%, 85%, 70%, 55%, 40%
        needs_xray = random.random() < (1 - (severity - 1) * 0.2)  # 100%, 80%, 60%, 40%, 20%
        
        # Paso 2: Laboratorio si es necesario
        lab_time = 0
        if needs_lab:
            lab_start = self.env.now
            # print(f"Paciente {patient_id} espera laboratorio en tiempo {self.env.now:.2f}")
            
            with self.labs.request(priority=severity) as req:
                yield req
                lab_service_start = self.env.now
                # print(f"Paciente {patient_id} inicia laboratorio en tiempo {self.env.now:.2f}")
                yield self.env.timeout(LAB_TIME)
                # print(f"Paciente {patient_id} termina laboratorio en tiempo {self.env.now:.2f}")
                self.lab_utilization.append((lab_service_start, self.env.now))
            
            lab_time = self.env.now - lab_start
        
        # Paso 3: Rayos X si es necesario
        xray_time = 0
        if needs_xray:
            xray_start = self.env.now
            # print(f"Paciente {patient_id} espera rayos X en tiempo {self.env.now:.2f}")
            
            with self.xray.request(priority=severity) as req:
                yield req
                xray_service_start = self.env.now
                # print(f"Paciente {patient_id} inicia rayos X en tiempo {self.env.now:.2f}")
                yield self.env.timeout(XRAY_TIME)
                # print(f"Paciente {patient_id} termina rayos X en tiempo {self.env.now:.2f}")
                self.xray_utilization.append((xray_service_start, self.env.now))
            
            xray_time = self.env.now - xray_start
        
        # Paso 4: Consulta con doctor
        doctor_start = self.env.now
        # print(f"Paciente {patient_id} espera doctor en tiempo {self.env.now:.2f}")
        
        with self.doctors.request(priority=severity) as req:
            yield req
            doctor_service_start = self.env.now
            # print(f"Paciente {patient_id} inicia consulta con doctor en tiempo {self.env.now:.2f}")
            yield self.env.timeout(DOCTOR_TIME[severity])
            # print(f"Paciente {patient_id} termina consulta con doctor en tiempo {self.env.now:.2f}")
            self.doctor_utilization.append((doctor_service_start, self.env.now))
        
        doctor_time = self.env.now - doctor_start
        
        # Registrar tiempo total del paciente en el sistema
        total_time = self.env.now - arrival_time
        waiting_time = total_time - triage_time - lab_time - xray_time - doctor_time
        
        all_patient_times.append((patient_id, severity, total_time, waiting_time))
        waiting_times_by_severity[severity].append(waiting_time)
        
        # print(f"Paciente {patient_id} completó todo el proceso en {total_time:.2f} minutos")
        # print(f"  - Tiempo de espera: {waiting_time:.2f} minutos")
        
        self.patients_seen += 1
        self.patients_waiting -= 1


def reset_statistics():
    """Reinicia todas las variables estadísticas globales"""
    global all_patient_times, severity_distribution, waiting_times_by_severity
    
    all_patient_times = []
    severity_distribution = {1: 0, 2: 0, 3: 0, 4: 0, 5: 0}
    waiting_times_by_severity = {1: [], 2: [], 3: [], 4: [], 5: []}


def calculate_utilization(usage_periods, sim_time, num_resources):
    """Calcula la utilización de recursos"""
    if not usage_periods:
        return 0.0
    
    # Crear un arreglo de ceros para cada minuto de la simulación
    timeline = np.zeros(int(sim_time) + 1)
    
    # Marcar los períodos en uso
    for start, end in usage_periods:
        start_idx = int(start)
        end_idx = min(int(end), int(sim_time))
        timeline[start_idx:end_idx + 1] = 1
    
    # Calcular utilización total
    total_used_time = np.sum(timeline)
    return (total_used_time / (sim_time * num_resources)) * 100


def calculate_cost_effectiveness(results, doctor_count, nurse_count, lab_count, xray_count):
    """Calcula eficiencia de costos basada en recursos y tiempos de espera"""
    # Costos de personal por día
    total_hours = SIM_TIME / 60  # Convertir minutos a horas
    doctor_cost = doctor_count * DOCTOR_SALARY_PER_HOUR * total_hours
    nurse_cost = nurse_count * NURSE_SALARY_PER_HOUR * total_hours
    
    # Costo diario amortizado de equipos
    daily_lab_cost = (LAB_EQUIPMENT_COST * lab_count) / EQUIPMENT_LIFESPAN_DAYS
    daily_xray_cost = (XRAY_EQUIPMENT_COST * xray_count) / EQUIPMENT_LIFESPAN_DAYS
    
    # Costo total diario
    total_daily_cost = doctor_cost + nurse_cost + daily_lab_cost + daily_xray_cost
    
    # Penalización por tiempos de espera (más peso a pacientes graves)
    weighted_wait = 0
    total_patients = results["patients_seen"]
    
    if total_patients > 0:
        weights = {1: 5, 2: 4, 3: 3, 4: 2, 5: 1}  # Severidad 1 es más importante
        for severity, waits in waiting_times_by_severity.items():
            if waits:  # Si hay pacientes con esta severidad
                weighted_wait += np.mean(waits) * weights[severity] * len(waits) / total_patients
    
    # Eficiencia = pacientes atendidos / (costo + penalización por espera)
    # Menor valor de weighted_wait es mejor
    if weighted_wait == 0:
        weighted_wait = 0.1  # Evitar división por cero
        
    # Puntaje de eficiencia: más pacientes atendidos, menor costo y menor tiempo de espera = mejor
    efficiency_score = results["patients_seen"] / (total_daily_cost / 10000 + weighted_wait)
    
    return {
        "total_cost": total_daily_cost,
        "weighted_wait": weighted_wait,
        "efficiency_score": efficiency_score
    }


def run_simulation(num_doctors: int, num_nurses: int, num_labs: int, 
                  num_xray: int, day_type: str = "weekday", verbose: bool = False) -> Dict[str, Any]:
    """Ejecuta la simulación con la configuración dada y devuelve estadísticas"""
    # Reiniciar estadísticas
    reset_statistics()
    
    # Configurar simulación
    env = simpy.Environment()
    hospital = Hospital(env, num_doctors, num_nurses, num_labs, num_xray)
    
    # Iniciar generador de pacientes
    env.process(hospital.patient_generator(day_type))
    
    # Ejecutar simulación
    env.run(until=SIM_TIME)
    
    # Calcular estadísticas básicas
    avg_time = np.mean([t[2] for t in all_patient_times]) if all_patient_times else 0
    avg_wait = np.mean([t[3] for t in all_patient_times]) if all_patient_times else 0
    patients_seen = len(all_patient_times)
    
    # Calcular utilizaciones
    doctor_utilization = calculate_utilization(hospital.doctor_utilization, SIM_TIME, num_doctors)
    nurse_utilization = calculate_utilization(hospital.nurse_utilization, SIM_TIME, num_nurses)
    lab_utilization = calculate_utilization(hospital.lab_utilization, SIM_TIME, num_labs)
    xray_utilization = calculate_utilization(hospital.xray_utilization, SIM_TIME, num_xray)
    
    # Calcular costos básicos
    total_hours = SIM_TIME / 60  # Convertir minutos a horas
    doctor_cost = num_doctors * DOCTOR_SALARY_PER_HOUR * total_hours
    nurse_cost = num_nurses * NURSE_SALARY_PER_HOUR * total_hours
    
    # Calcular tiempos de espera por severidad
    wait_by_severity = {sev: np.mean(times) if times else 0 for sev, times in waiting_times_by_severity.items()}
    
    results = {
        "patients_seen": patients_seen,
        "avg_time": avg_time,
        "avg_wait": avg_wait,
        "doctor_utilization": doctor_utilization,
        "nurse_utilization": nurse_utilization,
        "lab_utilization": lab_utilization,
        "xray_utilization": xray_utilization,
        "wait_by_severity": wait_by_severity
    }
    
    # Calcular eficiencia de costo
    cost_efficiency = calculate_cost_effectiveness(
        results, num_doctors, num_nurses, num_labs, num_xray)
    results.update(cost_efficiency)
    
    if verbose:
        # Imprimir resultados básicos
        print("\n----- RESULTADOS DE LA SIMULACIÓN -----")
        print(f"Configuración: D={num_doctors}, N={num_nurses}, L={num_labs}, X={num_xray}, Día: {day_type}")
        print(f"Pacientes atendidos: {patients_seen}")
        print(f"Tiempo promedio total: {avg_time:.2f} minutos")
        print(f"Tiempo promedio de espera: {avg_wait:.2f} minutos")
        print("Tiempos de espera por severidad:")
        for sev, wait in wait_by_severity.items():
            print(f"  - Severidad {sev}: {wait:.2f} minutos")
            
        print(f"Utilización doctores: {doctor_utilization:.2f}%")
        print(f"Utilización enfermeras: {nurse_utilization:.2f}%")
        print(f"Utilización laboratorios: {lab_utilization:.2f}%")
        print(f"Utilización rayos X: {xray_utilization:.2f}%")
        
        print(f"Costo total diario: Q{cost_efficiency['total_cost']:.2f}")
        print(f"Score de eficiencia: {cost_efficiency['efficiency_score']:.2f}")
        print("--------------------------------------")
    
    return results


def find_optimal_configuration(day_type: str) -> Tuple[int, int, int, int]:
    """
    Encuentra la configuración óptima de recursos para un tipo de día específico.
    Retorna (doctores, enfermeras, laboratorios, rayos X)
    """
    print(f"\n=== BUSCANDO CONFIGURACIÓN ÓPTIMA PARA: {day_type.upper()} ===")
    
    # Definir rangos a probar para cada recurso
    doctor_range = range(2, 7)  # 2-6 doctores
    nurse_range = range(3, 9)   # 3-8 enfermeras
    lab_range = range(1, 4)     # 1-3 laboratorios
    xray_range = range(1, 3)    # 1-2 equipos de rayos X
    
    # Para días más ocupados, ampliamos los rangos
    if day_type == "weekend":
        doctor_range = range(3, 8)  # 3-7 doctores
        nurse_range = range(4, 10)  # 4-9 enfermeras
    elif day_type == "holiday":
        doctor_range = range(4, 9)  # 4-8 doctores
        nurse_range = range(5, 11)  # 5-10 enfermeras
    
    best_config = None
    best_score = -1
    best_results = None
    
    total_configs = len(doctor_range) * len(nurse_range) * len(lab_range) * len(xray_range)
    print(f"Evaluando {total_configs} configuraciones posibles...")
    
    # Probar todas las combinaciones
    for doctors, nurses, labs, xrays in itertools.product(
            doctor_range, nurse_range, lab_range, xray_range):
        
        # Ejecutar simulación con esta configuración
        results = run_simulation(doctors, nurses, labs, xrays, day_type)
        
        # Criterio: mayor eficiencia de costos
        current_score = results["efficiency_score"]
        
        # Actualizar si es mejor
        if current_score > best_score:
            best_score = current_score
            best_config = (doctors, nurses, labs, xrays)
            best_results = results
    
    # Mostrar resultados de la mejor configuración
    doctors, nurses, labs, xrays = best_config
    print(f"\n----- MEJOR CONFIGURACIÓN PARA {day_type.upper()} -----")
    print(f"Doctores: {doctors}, Enfermeras: {nurses}, Laboratorios: {labs}, Rayos X: {xrays}")
    print(f"Pacientes atendidos: {best_results['patients_seen']}")
    print(f"Tiempo promedio total: {best_results['avg_time']:.2f} minutos")
    print(f"Tiempo promedio de espera: {best_results['avg_wait']:.2f} minutos")
    
    print("\nTiempos de espera por severidad:")
    for sev, wait in best_results['wait_by_severity'].items():
        # Verificar si hay pacientes con esa severidad
        count = len(waiting_times_by_severity[sev])
        if count > 0:
            print(f"  - Severidad {sev} ({count} pacientes): {wait:.2f} minutos")
        else:
            print(f"  - Severidad {sev}: No hay pacientes")
    
    print(f"\nUtilización de recursos:")
    print(f"  - Doctores: {best_results['doctor_utilization']:.2f}%")
    print(f"  - Enfermeras: {best_results['nurse_utilization']:.2f}%")
    print(f"  - Laboratorios: {best_results['lab_utilization']:.2f}%")
    print(f"  - Rayos X: {best_results['xray_utilization']:.2f}%")
    
    total_hours = SIM_TIME / 60  # Convertir minutos a horas
    doctor_cost = doctors * DOCTOR_SALARY_PER_HOUR * total_hours
    nurse_cost = nurses * NURSE_SALARY_PER_HOUR * total_hours
    daily_lab_cost = (LAB_EQUIPMENT_COST * labs) / EQUIPMENT_LIFESPAN_DAYS
    daily_xray_cost = (XRAY_EQUIPMENT_COST * xrays) / EQUIPMENT_LIFESPAN_DAYS
    total_cost = doctor_cost + nurse_cost + daily_lab_cost + daily_xray_cost
    
    print(f"\nCostos:")
    print(f"  - Doctores: Q{doctor_cost:.2f}")
    print(f"  - Enfermeras: Q{nurse_cost:.2f}")
    print(f"  - Laboratorios: Q{daily_lab_cost:.2f}")
    print(f"  - Rayos X: Q{daily_xray_cost:.2f}")
    print(f"  - TOTAL: Q{total_cost:.2f}")
    
    print(f"\nScore de eficiencia: {best_results['efficiency_score']:.2f}")
    print("------------------------------------------------")
    
    return best_config


def run_benchmark():
    """Ejecuta comparaciones de configuraciones para cada tipo de día"""
    print("\n" + "=" * 80)
    print("ANÁLISIS DE CONFIGURACIONES ÓPTIMAS".center(80))
    print("=" * 80)
    
    # Obtener mejores configuraciones para cada tipo de día
    optimal_weekday = find_optimal_configuration("weekday")
    optimal_weekend = find_optimal_configuration("weekend")
    optimal_holiday = find_optimal_configuration("holiday")
    
    # Resumen final de resultados
    print("\n" + "=" * 80)
    print("RESUMEN DE CONFIGURACIONES ÓPTIMAS".center(80))
    print("=" * 80)
    print(f"Día normal (weekday): {optimal_weekday[0]} doctores, {optimal_weekday[1]} enfermeras, {optimal_weekday[2]} laboratorios, {optimal_weekday[3]} rayos X")
    print(f"Fin de semana (weekend): {optimal_weekend[0]} doctores, {optimal_weekend[1]} enfermeras, {optimal_weekend[2]} laboratorios, {optimal_weekend[3]} rayos X")
    print(f"Día festivo (holiday): {optimal_holiday[0]} doctores, {optimal_holiday[1]} enfermeras, {optimal_holiday[2]} laboratorios, {optimal_holiday[3]} rayos X")
    
    return {
        "weekday": optimal_weekday,
        "weekend": optimal_weekend,
        "holiday": optimal_holiday
    }


def main():
    """Función principal del programa"""
    print("=" * 80)
    print("SIMULADOR DE SALA DE EMERGENCIAS HOSPITALARIAS".center(80))
    print("=" * 80)
    
    try:
        # Ejecutar análisis de configuraciones óptimas
        run_benchmark()
        
        print("\n" + "=" * 80)
        print("SIMULACIÓN COMPLETADA CON ÉXITO".center(80))
        print("=" * 80)
        
    except Exception as e:
        print(f"ERROR EN LA SIMULACIÓN: {e}")
        import traceback
        traceback.print_exc()


if __name__ == "__main__":
    main()
